!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e="undefined"!=typeof globalThis?globalThis:e||self).GameEngine=n()}(this,(function(){"use strict";const e={execute:(e,n)=>new Promise((t=>{const{actionCreator:r,gameFunction:o}=e;if(!r)throw new Error("actionCreator undefined");if(!o)throw new Error("gameFunction undefined");if(o.isGameOver(n))t();else{const e=o.stepKeys(n.getState()),i=(e,t)=>e.then((()=>(n.dispatch(r.setCurrentStep(t)),o.stepFunction[t](n))));R.reduce(i,Promise.resolve(),e).then((()=>{n.dispatch(r.setCurrentStep(void 0)),t()}))}}))};Object.freeze(e);const n={execute:(n,t,r={stepRunner:e})=>new Promise((e=>{const{actionCreator:o,gameFunction:i,selector:u}=n,{stepRunner:s}=r;if(!o)throw new Error("actionCreator undefined");if(!i)throw new Error("gameFunction undefined");if(i.isGameOver(t))e();else{const i=u.currentPlayerOrder(t.getState()),c=(e,i)=>e.then((()=>(t.dispatch(o.setCurrentPlayer(i)),s.execute(n,t,r))));R.reduce(c,Promise.resolve(),i).then((()=>{t.dispatch(o.setCurrentPlayer(void 0)),e()}))}}))};Object.freeze(n);const t={execute:(t,r,o={turnRunner:n,stepRunner:e})=>new Promise((e=>{const{actionCreator:n,gameFunction:i}=t,{turnRunner:u}=o;if(!n)throw new Error("actionCreator undefined");if(!i)throw new Error("gameFunction undefined");if(i.isGameOver(r))e();else{const s=i.phaseKeys(r.getState()),c=(e,i)=>e.then((()=>(r.dispatch(n.setCurrentPhase(i)),u.execute(t,r,o))));R.reduce(c,Promise.resolve(),s).then((()=>{r.dispatch(n.setCurrentPhase(void 0)),e()}))}}))};Object.freeze(t);const r={};r.executeRounds=(e,n,t,o)=>{const{gameFunction:i,roundLimit:u,selector:s}=e,{phaseRunner:c}=t;if(!u)throw new Error("roundLimit undefined");if(!s)throw new Error("selector undefined");if(!c)throw new Error("phaseRunner undefined");const a=s.currentRound(n.getState());i.isGameOver(n)||a>u?o():(((e,n)=>{const{actionCreator:t,selector:r}=e;if(!t)throw new Error("actionCreator undefined");if(!r)throw new Error("selector undefined");const o=r.currentRound(n.getState())+1;n.dispatch(t.setCurrentRound(o)),n.dispatch(t.setCurrentPhase(null)),n.dispatch(t.setCurrentPlayer(null))})(e,n),c.execute(e,n,t).then((()=>{r.executeRounds(e,n,t,o)})))},r.execute=(o,i,u={phaseRunner:t,turnRunner:n,stepRunner:e})=>new Promise((e=>{const{gameFunction:n}=o;if(!n)throw new Error("gameFunction undefined");n.isGameOver(i)?e():r.executeRounds(o,i,u,e)})),Object.freeze(r);const o={execute:(t,r,o={turnRunner:n,stepRunner:e})=>new Promise((e=>{const{actionCreator:n,gameFunction:i}=t,{turnRunner:u}=o;if(!n)throw new Error("actionCreator undefined");if(!i)throw new Error("gameFunction undefined");i.isGameOver(r)?e():(r.dispatch(n.setCurrentPhase("phase")),u.execute(t,r,o).then((()=>{r.dispatch(n.setCurrentPhase(void 0)),e()})))}))};Object.freeze(o);const i={execute:(e,n)=>new Promise((t=>{const{actionCreator:r,gameFunction:o}=e;if(!r)throw new Error("actionCreator undefined");if(!o)throw new Error("gameFunction undefined");o.isGameOver(n)?t():(n.dispatch(r.setCurrentStep("step")),o.stepFunction(n).then((()=>{n.dispatch(r.setCurrentStep(void 0)),t()})))}))};Object.freeze(i);const u={};return u.RoundRunner=r,u.PhaseRunner=t,u.TurnRunner=n,u.StepRunner=e,u.SinglePhaseRunner=o,u.SingleStepRunner=i,Object.freeze(u),u}));
