!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e="undefined"!=typeof globalThis?globalThis:e||self).GameEngine=n()}(this,(function(){"use strict";const e={execute:(e,n)=>new Promise((t=>{const{actionCreator:r,gameFunction:o}=e;if(R.isNil(r))throw new Error("actionCreator undefined");if(R.isNil(o))throw new Error("gameFunction undefined");if(o.isGameOver(n))t();else{const e=o.stepKeys(n.getState()),i=(e,t)=>e.then((()=>(n.dispatch(r.setCurrentStep(t)),o.stepFunction[t](n))));R.reduce(i,Promise.resolve(),e).then((()=>{n.dispatch(r.setCurrentStep(void 0)),t()}))}}))};Object.freeze(e);const n={},t=()=>Promise.resolve();n.execute=(n,r,o={stepRunner:e})=>new Promise((e=>{const{actionCreator:i,gameFunction:s,selector:u}=n;if(R.isNil(i))throw new Error("actionCreator undefined");if(R.isNil(s))throw new Error("gameFunction undefined");if(R.isNil(u))throw new Error("selector undefined");const c=s.turnStart||t,a=s.turnEnd||t,{stepRunner:d}=o;if(R.isNil(d))throw new Error("stepRunner undefined");if(s.isGameOver(r))e();else{const t=u.currentPlayerOrder(r.getState()),s=(e,t)=>e.then((()=>(r.dispatch(i.setCurrentPlayer(t)),c(r).then((()=>d.execute(n,r,o))).then((()=>a(r))))));R.reduce(s,Promise.resolve(),t).then((()=>{r.dispatch(i.setCurrentPlayer(void 0)),e()}))}})),Object.freeze(n);const r={},o=()=>Promise.resolve();r.execute=(t,r,i={turnRunner:n,stepRunner:e})=>new Promise((e=>{const{actionCreator:n,gameFunction:s}=t;if(R.isNil(n))throw new Error("actionCreator undefined");if(R.isNil(s))throw new Error("gameFunction undefined");const u=s.phaseStart||o,c=s.phaseEnd||o,{turnRunner:a}=i;if(R.isNil(a))throw new Error("turnRunner undefined");if(s.isGameOver(r))e();else{const o=s.phaseKeys(r.getState()),d=(e,o)=>e.then((()=>(r.dispatch(n.setCurrentPhase(o)),u(r).then((()=>a.execute(t,r,i))).then((()=>c(r))))));R.reduce(d,Promise.resolve(),o).then((()=>{r.dispatch(n.setCurrentPhase(void 0)),e()}))}})),Object.freeze(r);const i={},s=()=>Promise.resolve();i.executeRounds=(e,n,t,r)=>{const{gameFunction:o,roundLimit:u,selector:c}=e;if(R.isNil(o))throw new Error("gameFunction undefined");if(R.isNil(u))throw new Error("roundLimit undefined");if(R.isNil(c))throw new Error("selector undefined");const a=o.roundStart||s,d=o.roundEnd||s,{phaseRunner:h}=t;if(R.isNil(h))throw new Error("phaseRunner undefined");const f=c.currentRound(n.getState());o.isGameOver(n)||f>u?r():(((e,n)=>{const{actionCreator:t,selector:r}=e;if(!t)throw new Error("actionCreator undefined");if(!r)throw new Error("selector undefined");const o=r.currentRound(n.getState())+1;n.dispatch(t.setCurrentRound(o)),n.dispatch(t.setCurrentPhase(null)),n.dispatch(t.setCurrentPlayer(null))})(e,n),a(n).then((()=>h.execute(e,n,t))).then((()=>d(n))).then((()=>{i.executeRounds(e,n,t,r)})))},i.execute=(t,o,s={phaseRunner:r,turnRunner:n,stepRunner:e})=>new Promise((e=>{const{gameFunction:n}=t;if(!n)throw new Error("gameFunction undefined");n.isGameOver(o)?e():i.executeRounds(t,o,s,e)})),Object.freeze(i);const u={execute:(t,r,o={turnRunner:n,stepRunner:e})=>new Promise((e=>{const{actionCreator:n,gameFunction:i}=t,{turnRunner:s}=o;if(!n)throw new Error("actionCreator undefined");if(!i)throw new Error("gameFunction undefined");i.isGameOver(r)?e():(r.dispatch(n.setCurrentPhase("phase")),s.execute(t,r,o).then((()=>{r.dispatch(n.setCurrentPhase(void 0)),e()})))}))};Object.freeze(u);const c={execute:(e,n)=>new Promise((t=>{const{actionCreator:r,gameFunction:o}=e;if(!r)throw new Error("actionCreator undefined");if(!o)throw new Error("gameFunction undefined");o.isGameOver(n)?t():(n.dispatch(r.setCurrentStep("step")),o.stepFunction(n).then((()=>{n.dispatch(r.setCurrentStep(void 0)),t()})))}))};Object.freeze(c);const a={};return a.RoundRunner=i,a.PhaseRunner=r,a.TurnRunner=n,a.StepRunner=e,a.SinglePhaseRunner=u,a.SingleStepRunner=c,Object.freeze(a),a}));
