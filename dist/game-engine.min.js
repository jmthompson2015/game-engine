!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).GameEngine=t()}(this,(function(){"use strict";const e={execute:(e,t)=>new Promise((r=>{const{actionCreator:n,gameFunction:o}=e;if(!n)throw new Error("actionCreator undefined");if(!o)throw new Error("gameFunction undefined");if(o.isGameOver(t))r();else{const e=o.stepKeys(t.getState()),i=(e,r)=>e.then((()=>(t.dispatch(n.setCurrentStep(r)),o.stepFunction[r](t))));R.reduce(i,Promise.resolve(),e).then((()=>{t.dispatch(n.setCurrentStep(void 0)),r()}))}}))};Object.freeze(e);const t={execute:(t,r)=>new Promise((n=>{const{actionCreator:o,gameFunction:i,selector:s}=t;if(!o)throw new Error("actionCreator undefined");if(!i)throw new Error("gameFunction undefined");if(i.isGameOver(r))n();else{const i=s.currentPlayerOrder(r.getState()),c=(n,i)=>n.then((()=>(r.dispatch(o.setCurrentPlayer(i)),e.execute(t,r))));R.reduce(c,Promise.resolve(),i).then((()=>{r.dispatch(o.setCurrentPlayer(void 0)),n()}))}}))};Object.freeze(t);const r={execute:(e,r)=>new Promise((n=>{const{actionCreator:o,gameFunction:i}=e;if(!o)throw new Error("actionCreator undefined");if(!i)throw new Error("gameFunction undefined");if(i.isGameOver(r))n();else{const s=i.phaseKeys(r.getState()),c=(n,i)=>n.then((()=>(r.dispatch(o.setCurrentPhase(i)),t.execute(e,r))));R.reduce(c,Promise.resolve(),s).then((()=>{r.dispatch(o.setCurrentPhase(void 0)),n()}))}}))};Object.freeze(r);const n={};n.executeRounds=(e,t,o)=>{const{gameFunction:i,roundLimit:s,selector:c}=e;if(!s)throw new Error("roundLimit undefined");if(!c)throw new Error("selector undefined");const u=c.currentRound(t.getState());i.isGameOver(t)||u>s?o():(((e,t)=>{const{actionCreator:r,selector:n}=e;if(!r)throw new Error("actionCreator undefined");if(!n)throw new Error("selector undefined");const o=n.currentRound(t.getState())+1;t.dispatch(r.setCurrentRound(o)),t.dispatch(r.setCurrentPhase(null));const i=n.playersInOrder(t.getState());t.dispatch(r.setCurrentPlayerOrder(i)),t.dispatch(r.setCurrentPlayer(null))})(e,t),r.execute(e,t).then((()=>{n.executeRounds(e,t,o)})))},n.execute=(e,t)=>new Promise((r=>{const{gameFunction:o}=e;if(!o)throw new Error("gameFunction undefined");o.isGameOver(t)?r():n.executeRounds(e,t,r)})),Object.freeze(n);const o={};return o.RoundRunner=n,Object.freeze(o),o}));
