!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e="undefined"!=typeof globalThis?globalThis:e||self).GameEngine=n()}(this,(function(){"use strict";const e={execute:(e,n)=>new Promise((t=>{const{actionCreator:r,gameFunction:i}=e;if(R.isNil(r))throw new Error("actionCreator undefined");if(R.isNil(i))throw new Error("gameFunction undefined");if(i.isGameOver(n))t();else{const e=i.stepKeys(n.getState()),o=(e,t)=>e.then((()=>(n.dispatch(r.setCurrentStep(t)),i.stepFunction[t](n))));R.reduce(o,Promise.resolve(),e).then((()=>{n.dispatch(r.setCurrentStep(void 0)),t()}))}}))};Object.freeze(e);const n={},t=()=>Promise.resolve();n.execute=(n,r,i={stepRunner:e})=>new Promise((e=>{const{actionCreator:o,gameFunction:s,selector:u}=n;if(R.isNil(o))throw new Error("actionCreator undefined");if(R.isNil(s))throw new Error("gameFunction undefined");if(R.isNil(u))throw new Error("selector undefined");const c=s.turnStart||t,a=s.turnEnd||t,{stepRunner:d}=i;if(R.isNil(d))throw new Error("stepRunner undefined");if(s.isGameOver(r))e();else{const t=u.currentPlayerOrder(r.getState()),s=(e,t)=>e.then((()=>(r.dispatch(o.setCurrentPlayer(t)),c(r).then((()=>d.execute(n,r,i))).then((()=>a(r))))));R.reduce(s,Promise.resolve(),t).then((()=>{r.dispatch(o.setCurrentPlayer(void 0)),e()}))}})),Object.freeze(n);const r={},i=()=>Promise.resolve();r.execute=(t,r,o={turnRunner:n,stepRunner:e})=>new Promise((e=>{const{actionCreator:n,gameFunction:s}=t;if(R.isNil(n))throw new Error("actionCreator undefined");if(R.isNil(s))throw new Error("gameFunction undefined");const u=s.phaseStart||i,c=s.phaseEnd||i,{turnRunner:a}=o;if(R.isNil(a))throw new Error("turnRunner undefined");if(s.isGameOver(r))e();else{const i=s.phaseKeys(r.getState()),d=(e,i)=>e.then((()=>(r.dispatch(n.setCurrentPhase(i)),u(r).then((()=>a.execute(t,r,o))).then((()=>c(r))))));R.reduce(d,Promise.resolve(),i).then((()=>{r.dispatch(n.setCurrentPhase(void 0)),e()}))}})),Object.freeze(r);const o={},s=()=>Promise.resolve();o.executeRounds=(e,n,t,r)=>{const{gameFunction:i,roundLimit:u,selector:c}=e;if(R.isNil(i))throw new Error("gameFunction undefined");if(R.isNil(u))throw new Error("roundLimit undefined");if(R.isNil(c))throw new Error("selector undefined");const a=i.roundStart||s,d=i.roundEnd||s,{phaseRunner:h}=t;if(R.isNil(h))throw new Error("phaseRunner undefined");const f=c.currentRound(n.getState());i.isGameOver(n)||f>u?r():(((e,n)=>{const{actionCreator:t,selector:r}=e;if(!t)throw new Error("actionCreator undefined");if(!r)throw new Error("selector undefined");const i=r.currentRound(n.getState())+1;n.dispatch(t.setCurrentRound(i)),n.dispatch(t.setCurrentPhase(null)),n.dispatch(t.setCurrentPlayer(null))})(e,n),a(n).then((()=>h.execute(e,n,t))).then((()=>d(n))).then((()=>{o.executeRounds(e,n,t,r)})))},o.execute=(t,i,s={phaseRunner:r,turnRunner:n,stepRunner:e})=>new Promise((e=>{const{gameFunction:n}=t;if(!n)throw new Error("gameFunction undefined");n.isGameOver(i)?e():o.executeRounds(t,i,s,e)})),Object.freeze(o);const u={},c=()=>Promise.resolve();u.execute=(t,r,i={turnRunner:n,stepRunner:e})=>new Promise((e=>{const{actionCreator:n,gameFunction:o}=t,{turnRunner:s}=i;if(R.isNil(n))throw new Error("actionCreator undefined");if(R.isNil(o))throw new Error("gameFunction undefined");const u=o.phaseStart||c,a=o.phaseEnd||c;o.isGameOver(r)?e():(r.dispatch(n.setCurrentPhase("phase")),u(r).then((()=>s.execute(t,r,i))).then((()=>a(r))).then((()=>{r.dispatch(n.setCurrentPhase(void 0)),e()})))})),Object.freeze(u);const a={execute:(e,n)=>new Promise((t=>{const{actionCreator:r,gameFunction:i}=e;if(R.isNil(r))throw new Error("actionCreator undefined");if(R.isNil(i))throw new Error("gameFunction undefined");i.isGameOver(n)?t():(n.dispatch(r.setCurrentStep("step")),i.stepFunction(n).then((()=>{n.dispatch(r.setCurrentStep(void 0)),t()})))}))};Object.freeze(a);const d={};return d.RoundRunner=o,d.PhaseRunner=r,d.TurnRunner=n,d.StepRunner=e,d.SinglePhaseRunner=u,d.SingleStepRunner=a,Object.freeze(d),d}));
